\section{Introduction}\label{index_intro_sec}
\doxyref{D\-S\-Patch}{p.}{class_d_s_patch}, pronounced \char`\"{}dispatch\char`\"{}, is a powerful C++ flow-\/based programming library that allows you to create and route (or \char`\"{}patch\char`\"{}) high performance data processing circuits. \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} is not limited to any particular type of circuit or signal, its generic object-\/oriented A\-P\-I allows you to create almost any process chain imaginable, from simple logic circuits to full-\/blown electronics simulation. \doxyref{D\-S\-Patch}{p.}{class_d_s_patch}'s simple framework makes development quick and easy, allowing you to hit the ground running on every project.

\doxyref{D\-S\-Patch}{p.}{class_d_s_patch} is designed around the concept of a \char`\"{}circuit\char`\"{} containing \char`\"{}components\char`\"{}, interconnected via \char`\"{}wires\char`\"{} that transfer \char`\"{}signals\char`\"{} to and from input and output \char`\"{}buses\char`\"{}. For more detail on how \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} works, check out the {\tt {\bfseries D\-S\-Patch Design Specification}}.

The two most important classes to consider are \doxyref{Dsp\-Component}{p.}{class_dsp_component} and \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit}. In order to route data to and from Dsp\-Components they can either be added to an \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit}, where they can be wired together (recommended), or they can be wired directly via public \doxyref{Dsp\-Component}{p.}{class_dsp_component} methods. The \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} engine takes care of data transfer between interconnected components, when data is ready for a component to process, a callback\-: \char`\"{}\-Process\-\_\-()\char`\"{} is executed in that component. For a component to form part of the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} framework, designers simply have to derive their component from the \doxyref{Dsp\-Component}{p.}{class_dsp_component} base class, configure the component's I\-O buses, and implement the virtual Process\-\_\-() callback method.

\par
\section{Features}\label{index_features_sec}

\begin{DoxyItemize}
\item {\bfseries Automatic branch synchronization} -\/ The result of data diverging across parallel branches is guaranteed to arrive synchronized at a converging point.
\item {\bfseries Dynamic thread count adjustment} -\/ Specify at run-\/time, the number of threads in which you require a circuit to process.
\item {\bfseries Easy-\/to-\/use object-\/oriented A\-P\-I} -\/ \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} is modeled around real-\/world circuit entities and concepts, making code more readable and easy to understand.
\item {\bfseries Feedback loops} -\/ Create true closed-\/circuit systems by feeding resultant signals back into previous component inputs.
\item {\bfseries High performance parallel processing} -\/ Circuits use advanced multi-\/threaded scheduling to maximize data flow efficiency.
\item {\bfseries Integrated circuits} -\/ Build circuits within circuits to encapsulate complex component networks into single circuit components.
\item {\bfseries Non-\/threaded platform support} -\/ Develop for (or port to) platforms without multi-\/threading support and process complex circuit systems in a single thread.
\item {\bfseries Run-\/time circuit wiring} -\/ Connect and disconnect wires on the fly whilst maintaining steady data flow through the system.
\item {\bfseries Run-\/time adaptive signal types} -\/ Component inputs can accept values of run-\/time varying types allowing you to create more flexible, multi-\/purpose component processes.
\end{DoxyItemize}

\par
\section{Getting Started}\label{index_install_sec}
\subsection{Step 1\-: Download D\-S\-Patch}\label{index_step1}
The \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} library can be downloaded from the {\tt {\bfseries Source\-Forge project page}}. Download the project archive and extract the contents anywhere you like.\subsection{Step 2\-: Read the Tutorials}\label{index_step2}
The \char`\"{}\-Tutorials\char`\"{} section below covers 2 vital aspects to developing with \doxyref{D\-S\-Patch}{p.}{class_d_s_patch}\-:
\begin{DoxyEnumerate}
\item Creating a \doxyref{Dsp\-Component}{p.}{class_dsp_component} -\/ This tutorial is a start to finish demonstration of how to create a \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} component.
\item Building a \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} -\/ In this tutorial you will learn how to use the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} framework to interconnect and process \doxyref{Dsp\-Component}{p.}{class_dsp_component} networks using the \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} interface.
\end{DoxyEnumerate}\subsection{Step 3\-: Check out the Dsp\-Demo project}\label{index_step3}
In the \char`\"{}example\char`\"{} folder (in the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} root directory) you will find a simple \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} example project\-: \char`\"{}\-Dsp\-Demo\char`\"{}. This project has been written to assist developers in understanding the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} A\-P\-I as well as to demonstrate how it could be used to build a real-\/time audio process chain. The quickest way to get this project compiled and running is to simply open the \char`\"{}dspdemo.\-sln\char`\"{} (Windows) or \char`\"{}dspdemo.\-xcodeproj\char`\"{} (Mac O\-S X) file (found in the \char`\"{}/example/windows\char`\"{}, and \char`\"{}/example/mac\-\_\-os\-\_\-x\char`\"{} directories respectively) depending on the platform used -\/\-This solution contains both the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} library and Dsp\-Demo project side-\/by-\/side as would be typical in developing a \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} application.\subsection{Step 4\-: Make your own Dsp\-Components}\label{index_step4}
A fast way to create your own \doxyref{Dsp\-Component}{p.}{class_dsp_component} could be to copy an existing component to another destination, rename it, and edit the contents to satisfy your component's required behavior. In the \char`\"{}example\char`\"{} folder (from Step 3) you will find 2 source files\-: \char`\"{}\-Dsp\-Adder.\-h\char`\"{} and \char`\"{}\-Dsp\-Adder.\-cpp\char`\"{}. These files make up a very simple \doxyref{Dsp\-Component}{p.}{class_dsp_component} that receives 2 floating-\/point buffers into it's 2 inputs, adds each buffer element of the 1st buffer to the corresponding element of the 2nd buffer, then passes the resultant buffer to the output. Alternatively, you could just copy / reference the source code from the \char`\"{}\-Creating a Dsp\-Component\char`\"{} tutorial (found under the \char`\"{}tutorial\char`\"{} folder in the root directory).\subsection{Step 5\-: Roll your own D\-S\-Patch projects}\label{index_step5}
As \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} is not reliant on any non-\/standard 3rd party sources, getting a \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} project to compile and run is relatively painless. All you need to do from your project is \#include \char`\"{}\-D\-S\-Patch.\-h\char`\"{} from the \char`\"{}include\char`\"{} folder (in the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} root directory), and link to the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} library (either by including all \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} source or by linking to a compiled library file). To speed things up you may want to copy, rename, and edit the Dsp\-Demo project from step 3 to get up and running faster.\subsection{Step 6\-: Refer to the documentation}\label{index_step6}
Between the Dsp\-Demo project, the Dsp\-Adder component template, and the documentation found here, you should have enough resources to get started with \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} straight away. If you have any questions or wish to report a bug, feel free to email me at {\tt marcus@adaptaudio.\-com}.

\par
\section{Tutorials}\label{index_tutorial_sec}
\subsection{1. Creating a Dsp\-Component}\label{index_create_component}
In order to create a new \doxyref{Dsp\-Component}{p.}{class_dsp_component}, we must derive our component class from the \doxyref{Dsp\-Component}{p.}{class_dsp_component} base class, configure component I\-O, and implement the inherited virtual \char`\"{}\-Process\-\_\-()\char`\"{} method.

Lets take a look at how we would go about creating a boolean logic \char`\"{}\-A\-N\-D\char`\"{} component. This component will accept 2 boolean input values and output the result of\-: input 1 \&\& input 2.

We begin by deriving our new \char`\"{}\-Dsp\-And\char`\"{} component from \doxyref{Dsp\-Component}{p.}{class_dsp_component}\-:


\begin{DoxyCode}
\textcolor{comment}{// 1. Derive component class from DspComponent}
\textcolor{comment}{// ===========================================}
\textcolor{keyword}{class }DspAnd : \textcolor{keyword}{public} DspComponent
\{
\end{DoxyCode}


The next step is to configure our component's input and output buses. This is achieved by calling the base protected methods Add\-Input\-\_\-() and Add\-Output\-\_\-() respectively from our component's constructor. Each method must be called once per input / output required. In our component's case, we require 2 inputs and 1 output, therefore our constructor code will look like this\-:


\begin{DoxyCode}
\textcolor{keyword}{public}:
  \textcolor{comment}{// 2. Configure component IO buses}
  \textcolor{comment}{// ===============================}
  DspAnd()
  \{
    \textcolor{comment}{// add 2 inputs}
    AddInput\_( \textcolor{stringliteral}{"input1"} );
    AddInput\_( \textcolor{stringliteral}{"input2"} );

    \textcolor{comment}{// add 1 output}
    AddOutput\_( \textcolor{stringliteral}{"output"} );
  \}
\end{DoxyCode}


The string values passed into the Add\-Input\-\_\-() and Add\-Output\-\_\-() method calls are signal names / I\-Ds. As component I\-O can be referenced by either string I\-D or index, I\-O signal names are optional. If we do not require a signal to have a string I\-D associated with it, we can simply leave the parenthesis empty.

Lastly, our component must implement the \doxyref{Dsp\-Component}{p.}{class_dsp_component} virtual Process\-\_\-() method. This is where our component does it's work. The Process\-\_\-() method provides us with 2 parameters\-: the input bus and the output bus. It is our duty as the component designer to pull the inputs we require out of the input bus, process them accordingly, and populate the output bus with the results. Our component's process method will look something like this\-:


\begin{DoxyCode}
\textcolor{keyword}{protected}:
  \textcolor{comment}{// 3. Implement virtual Process\_() method}
  \textcolor{comment}{// ======================================}
  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Process\_( DspSignalBus& inputs, DspSignalBus& outputs )
  \{
    \textcolor{comment}{// create local stack variables to hold input values}
    \textcolor{keywordtype}{bool} bool1 = \textcolor{keyword}{false};
    \textcolor{keywordtype}{bool} bool2 = \textcolor{keyword}{false};

    \textcolor{comment}{// get values from inputs bus ( GetValue() returns true if successful )}
    \textcolor{keywordflow}{if}( inputs.GetValue( 0, bool1 ) && \textcolor{comment}{//OR inputs.GetValue( "input1", bool1 );}
        inputs.GetValue( 1, bool2 ) )  \textcolor{comment}{//OR inputs.GetValue( "input2", bool2 );}
    \{
      \textcolor{comment}{// set output as the result of bool1 AND bool2}
      outputs.SetValue( 0, bool1 && bool2 ); \textcolor{comment}{//OR outputs.SetValue( "output",
       bool1 && bool2 );}
    \}
  \}
\};
\end{DoxyCode}


And that's it! Our component is now ready to form part of the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} framework. Next we'll look at how we can add our component to a \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} and route it to and from other Dsp\-Components.

\par
\subsection{2. Building a Dsp\-Circuit}\label{index_use_component}
In order for us to get any real use out of our Dsp\-Components, we need them to interact with each other. This is where the \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} class comes in. A \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} is a workspace for adding and routing Dsp\-Components. In this section we will have a look at how to create a simple \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} application that generates random boolean pairs, performs a logic A\-N\-D on each pair, then prints the result to screen.

First we must include the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} header and any other headers that contain Dsp\-Components we wish to use in our application\-:


\begin{DoxyCode}
\textcolor{preprocessor}{#include "DSPatch.h"}
\textcolor{preprocessor}{#include "components.h"}
\end{DoxyCode}


Next, we must instantiate our \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} object and all \doxyref{Dsp\-Component}{p.}{class_dsp_component} objects needed for our circuit. Lets say we had 2 other components included with \char`\"{}\-Dsp\-And\char`\"{} (from the first tutorial)\-: \char`\"{}\-Dsp\-Rand\-Bool\char`\"{} (generates a random boolean value then outputs the result) and \char`\"{}\-Dsp\-Print\-Bool\char`\"{} (receives a boolean value and outputs it to the console)\-:


\begin{DoxyCode}
\textcolor{keywordtype}{void} main()
\{
  \textcolor{comment}{// 1. Create a DspCircuit where we can route our components}
  \textcolor{comment}{// ========================================================}
  DspCircuit circuit;

  \textcolor{comment}{// 2. Create instances of the components needed for our circuit}
  \textcolor{comment}{// ============================================================}
  DspRandBool randBoolGen1;
  DspRandBool randBoolGen2;
  DspAnd logicAnd;
  DspPrintBool boolPrinter;
\end{DoxyCode}


Now that we have a circuit and some components, lets add all of our components to the circuit\-:


\begin{DoxyCode}
\textcolor{comment}{// 3. Add component instances to circuit}
\textcolor{comment}{// =====================================}
circuit.AddComponent( randBoolGen1, \textcolor{stringliteral}{"Bool Generator 1"} );
circuit.AddComponent( randBoolGen2, \textcolor{stringliteral}{"Bool Generator 2"} );
circuit.AddComponent( logicAnd, \textcolor{stringliteral}{"Logic AND"} );
circuit.AddComponent( boolPrinter, \textcolor{stringliteral}{"Bool Printer"} );
\end{DoxyCode}


The string values passed into the Add\-Component() method calls are component names / I\-Ds. Although we still have the option of referencing a component via it's pointer in a circuit, component string I\-Ds can allow circuit objects to be entirely self-\/contained. This could give us the ability to pass circuits around by reference, allowing the receiver access to all circuit components via their string I\-Ds, without having to manage both component and circuit references everywhere.

We are now ready to begin wiring the circuit\-:


\begin{DoxyCode}
\textcolor{comment}{// 4. Wire up the components inside the circuit}
\textcolor{comment}{// ============================================}

circuit.ConnectOutToIn( randBoolGen1, 0, logicAnd, 0 );
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Bool Generator 1", 0, "Logic AND", 0 );}
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Bool Generator 1", 0, "Logic AND", "input1" );}

circuit.ConnectOutToIn( randBoolGen2, 0, logicAnd, 1 );
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Bool Generator 2", 0, "Logic AND", 1 );}
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Bool Generator 2", 0, "Logic AND", "input2" );}

circuit.ConnectOutToIn( logicAnd, 0, boolPrinter, 0 );
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Logic AND", 0, "Bool Printer", 0 );}
\textcolor{comment}{//OR circuit.ConnectOutToIn( "Logic AND", "output", "Bool Printer", 0 );}
\end{DoxyCode}


The code above results in the following wiring configuration\-: 
\begin{DoxyCode}
                               \_\_\_\_\_\_\_\_\_\_\_
[\textcolor{stringliteral}{"Bool Generator 1"}] 0 ---> 0 |           |
                              |\textcolor{stringliteral}{"Logic AND"}| 0 ---> 0 [\textcolor{stringliteral}{"Bool Printer"}]
[\textcolor{stringliteral}{"Bool Generator 2"}] 0 ---> 1 |\_\_\_\_\_\_\_\_\_\_\_|
\end{DoxyCode}


$\ast$\-N.B. Each component input can only accept one wire at a time. When another wire is connected to an input that already has a connected wire, that wire is replaced with the new one. One output, on the other hand, can be distributed to multiple inputs.

Lastly, in order for our circuit to do any work it must be ticked over. This is performed by repeatedly calling the circuit's Tick() and Reset() methods. These methods can be called manually in a loop from the main application thread, or alternatively, by calling Start\-Auto\-Tick(), a seperate thread will spawn, automatically calling Tick() and Reset() continuously. A circuit's thread count can be adjusted at runtime, allowing us to increase / decrease the number of threads use by the circuit as required during execution\-:


\begin{DoxyCode}
\textcolor{comment}{// 5. Tick the circuit}
\textcolor{comment}{// ===================}

\textcolor{comment}{// Circuit tick method 1: Manual}
\textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} i = 0; i < 10; i++ )
\{
  circuit.Tick();
  circuit.Reset();
\}

\textcolor{comment}{// Circuit tick method 2: Automatic}
std::cout << \textcolor{stringliteral}{"Press any key to begin circuit auto-tick."};
getchar();
circuit.StartAutoTick();

\textcolor{comment}{// Increase circuit thread count for higher performance}
getchar();
circuit.SetThreadCount( 4 );

\textcolor{comment}{// Press any key to quit}
getchar();
\end{DoxyCode}


Lastly, the D\-S\-Patch\-::\-Finalize() method must be called on application exit in order for \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} to perform its own internal memory cleanup.


\begin{DoxyCode}
  \textcolor{comment}{// 6. Clean up}
  \textcolor{comment}{// ===========}
  DSPatch::Finalize();
\}
\end{DoxyCode}


(All the source code from these tutorials can be found under the \char`\"{}tutorial\char`\"{} folder in the \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} root directory).

\par
\section{Release Notes}\label{index_release_notes}
\subsection{v.\-2.\-31 (19 December 2012)}\label{index_v231}

\begin{DoxyItemize}
\item Improved synchronization in Add\-Component().
\item Component routing upgraded to template methods.
\end{DoxyItemize}\subsection{v.\-2.\-30 (15 December 2012)}\label{index_v230}

\begin{DoxyItemize}
\item Circuit routing simplified.
\item Completed \char`\"{}circuit-\/less\char`\"{} component processing.
\item Component names now optional.
\item \doxyref{Dsp\-Circuit}{p.}{class_dsp_circuit} no longer deletes external memory.
\item Optimized circuit-\/in-\/circuit processing.
\end{DoxyItemize}\subsection{v.\-2.\-2 (08 December 2012)}\label{index_v22}

\begin{DoxyItemize}
\item A component can no longer exist in multiple circuits.
\item Added coding tutorials
\item Cleaned up project directory structure.
\item Comments and documentation updates.
\item Resolved component / circuit thread count clash.
\end{DoxyItemize}\subsection{v.\-2.\-1 (06 November 2012)}\label{index_v21}

\begin{DoxyItemize}
\item Removed Dsp\-Safe\-Pointer class.
\item Greatly improved overall performance.
\item Added commenting for doxygen.
\end{DoxyItemize}\subsection{v.\-2.\-0 (02 November 2012)}\label{index_v20}

\begin{DoxyItemize}
\item Re-\/licensed \doxyref{D\-S\-Patch}{p.}{class_d_s_patch} to L\-G\-P\-L.
\item Added support for non-\/threaded platforms.
\item Circuit routing upgraded to more flexible template methods.
\end{DoxyItemize}\subsection{v.\-1.\-2 (20 October 2012)}\label{index_v12}

\begin{DoxyItemize}
\item Ported to Unix-\/based O\-S's.
\item Completed circuit-\/in-\/circuit logic.
\end{DoxyItemize}\subsection{v.\-1.\-1 (17 October 2012)}\label{index_v11}

\begin{DoxyItemize}
\item Varies bug fixes.
\item Added 2 more components to the Dsp\-Demo project.
\item Optimized threaded circuit processing.
\item Add\-Component() updated to accept pre-\/constructed Dsp\-Components.
\end{DoxyItemize}\subsection{v.\-1.\-0 (14 October 2012)}\label{index_v10}

\begin{DoxyItemize}
\item Extracted routing engine behind \char`\"{}\-Crosstalk\char`\"{} to form\-: \char`\"{}\-D\-S\-Patch\char`\"{}. 
\end{DoxyItemize}