<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DSPatch: Welcome</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="heartbeat.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DSPatch
   &#160;<span id="projectnumber">v.2.2</span>
   </div>
   <div id="projectbrief">C++ Cross-Platform, Object-Oriented, Flow-Based Programming Library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Welcome </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="intro_sec"></a>
Introduction</h2>
<p>DSPatch, pronounced "dispatch", is a powerful C++ flow-based programming library that allows you to create and route (or "patch") high performance signal processing circuits. DSPatch is not limited to any particular type of circuit or signal, its generic object-oriented API allows you to create almost any process chain imaginable, from simple logic circuits to full-blown electronics simulation. DSPatch's simple framework makes development quick and easy, allowing you to hit the ground running on every project.</p>
<p>The two most important classes to consider are <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> and <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a>. In order to route data to and from DspComponents they can either be added to an <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a>, where they can be wired together (recommended), or they can be wired directly via public <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> methods. The DSPatch engine takes care of all data transfer between interconnected components, when data is ready for a component to process, a callback: "Process_()" is executed in that component. For a component to form part of the DSPatch framework, designers simply have to derive their component from the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> base class, configure the component IO in the component constructor, and implement the virtual Process_() callback method.</p>
<p>For more detail on how DSPatch works, check out the <a href="spec_page.html"><b>DSPatch Design Specification</b></a>.</p>
<p><br/>
</p>
<h2><a class="anchor" id="features_sec"></a>
Features</h2>
<ul>
<li>Automatic branch synchronization.</li>
<li>Dynamic thread count adjustment.</li>
<li>Easy-to-use object-oriented API.</li>
<li>Feedback loops.</li>
<li>High performance parallel processing.</li>
<li>Integrated circuits.</li>
<li>Non-threaded platform support.</li>
<li>Run-time circuit wiring.</li>
<li>Run-time adaptive signal types.</li>
</ul>
<p><br/>
</p>
<h2><a class="anchor" id="install_sec"></a>
Getting Started</h2>
<h3><a class="anchor" id="step1"></a>
Step 1: Download DSPatch</h3>
<p>The DSPatch library can be downloaded from the <a href="https://sourceforge.net/projects/dspatch/"><b>SourceForge project page</b></a>. Download the project archive and extract the contents anywhere you like.</p>
<h3><a class="anchor" id="step2"></a>
Step 2: Read the Tutorials</h3>
<p>The "Tutorials" section (below) covers 2 vital aspects to developing with DSPatch:</p>
<ol type="1">
<li>Creating a <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> - This tutorial is a start to finish demonstration of how to create a DSPatch component.</li>
<li>Building a <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> - In this tutorial you will learn how to use the DSPatch framework to interconnect and process <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> networks using the <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> interface.</li>
</ol>
<h3><a class="anchor" id="step3"></a>
Step 3: Check out the DspDemo project</h3>
<p>In the "example" folder (in the DSPatch root directory) you will find a simple DSPatch example project: "DspDemo". This project has been written to assist developers in understanding the DSPatch API as well as to demonstrate how it could be used to build a real-time audio process chain. The quickest way to get this project compiled and running is to simply open the "dspdemo.sln" (Windows) or "dspdemo.xcodeproj" (Mac OS X) file (found in the "/example/windows", and "/example/mac_os_x" directories respectively) depending on the platform used -This solution contains both the DSPatch library and DspDemo project side-by-side as would be typical in developing a DSPatch application.</p>
<h3><a class="anchor" id="step4"></a>
Step 4: Make your own DspComponents</h3>
<p>A fast way to create your own <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> could be to copy an existing component to another destination, rename it, and edit the contents to satisfy your component's required behavior. In the "example" folder (from Step 3) you will find 2 source files: "DspAdder.h" and "DspAdder.cpp". These files make up a very simple <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> that receives 2 floating-point buffers into it's 2 inputs, adds each buffer element of the 1st buffer to the corresponding element of the 2nd buffer, then passes the resultant buffer to the output. Alternatively, you could just copy / reference the source code from the "Creating a DspComponent" tutorial (found under the "tutorial" folder in the root directory).</p>
<h3><a class="anchor" id="step5"></a>
Step 5: Roll your own DSPatch projects</h3>
<p>As DSPatch is not reliant on any non-standard 3rd party sources, getting a DSPatch project to compile and run is relatively painless. All you need to do from your project is #include "DSPatch.h" from the "include" folder (in the DSPatch root directory), and link to the DSPatch library (either by including all DSPatch source or by linking to a compiled library file). To speed things up you may want to copy, rename, and edit the DspDemo project from step 3 to get up and running faster.</p>
<h3><a class="anchor" id="step6"></a>
Step 6: Refer to the documentation</h3>
<p>Between the DspDemo project, the DspAdder component template, and the documentation found here, you should have enough resources to get started with DSPatch straight away. If you have any questions or wish to report a bug, feel free to email me at <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'cu'+'s@a'+'da'+'pta'+'ud'+'io.'+'co'+'m'; return false;">marcu<span style="display: none;">.nosp@m.</span>s@ad<span style="display: none;">.nosp@m.</span>aptau<span style="display: none;">.nosp@m.</span>dio.<span style="display: none;">.nosp@m.</span>com</a>.</p>
<p><br/>
</p>
<h2><a class="anchor" id="tutorial_sec"></a>
Tutorials</h2>
<h3><a class="anchor" id="create_component"></a>
1. Creating a DspComponent</h3>
<p>In order to create a new <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a>, we must derive our component class from the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> base class, configure component IO, and implement the inherited pure virtual "Process_()" method.</p>
<p>Lets take a look at how we would go about creating a boolean logic "AND" component. This component will accept 2 boolean input values and output the result of: input 1 &amp;&amp; input 2.</p>
<p>We begin by deriving our new "DspAnd" component from <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a>:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>DspAnd : <span class="keyword">public</span> <a class="code" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a>
{
</pre></div><p>The next step is to configure our component's input and output buses. This is achieved by calling the base protected methods AddInput_() and AddOutput_() respectively from our component's constructor. Each method must be called once per input / output required. In our component's case, we require 2 inputs and 1 output, therefore our constructor code will look like this:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span>:
        DspAnd()
        {
                <span class="comment">// add 2 inputs</span>
                AddInput_( <span class="stringliteral">&quot;input1&quot;</span> );
                AddInput_( <span class="stringliteral">&quot;input2&quot;</span> );

                <span class="comment">// add 1 output</span>
                AddOutput_( <span class="stringliteral">&quot;output&quot;</span> );
        }
</pre></div><p>The string values passed into the AddInput_() and AddOutput_() method calls are signal names / IDs. As component IO can be referenced by either string ID or index, IO signal names are optional. If we do not require a signal to have a string ID associated with it, we can simply leave the parenthesis empty.</p>
<p>Lastly, our component must implement the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> pure virtual Process_() method. This is where our component does it's work. The Process_() method provides us with 2 parameters: the input bus and the output bus. It is our duty as the component designer to pull the inputs we require out of the input bus, process them accordingly, and populate the output bus with the results. Our component's process method will look something like this:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">protected</span>:
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> Process_( <a class="code" href="class_dsp_signal_bus.html" title="DspSignal container.">DspSignalBus</a>&amp; inputs, <a class="code" href="class_dsp_signal_bus.html" title="DspSignal container.">DspSignalBus</a>&amp; outputs )
        {
                <span class="comment">// create local stack variables to hold input values</span>
                <span class="keywordtype">bool</span> state1 = <span class="keyword">false</span>;
                <span class="keywordtype">bool</span> state2 = <span class="keyword">false</span>;

                <span class="comment">// get values from inputs bus ( GetValue() returns true if successful )</span>
                <span class="keywordflow">if</span>( inputs.GetValue( <span class="stringliteral">&quot;input1&quot;</span>, state1 ) &amp;&amp;  <span class="comment">// equivalent: inputs.GetValue( 0, state1 );</span>
                    inputs.GetValue( <span class="stringliteral">&quot;input2&quot;</span>, state2 ) )   <span class="comment">// equivalent: inputs.GetValue( 1, state2 );</span>
                {
                        <span class="comment">// set output as the result of state1 AND state2</span>
                        outputs.SetValue( <span class="stringliteral">&quot;output&quot;</span>, state1 &amp;&amp; state2 ); <span class="comment">// equivalent: outputs.SetValue( 0, state1 &amp;&amp; state2 );</span>
                }
        }
};
</pre></div><p>And that's it! Our component is now ready to form part of the DSPatch framework. Next we'll look at how we can add our component to a <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> and route it to and from other DspComponents.</p>
<p><br/>
</p>
<h3><a class="anchor" id="use_component"></a>
2. Building a DspCircuit</h3>
<p>In order for us to get any real use out of our DspComponents, we need them to interact with each other. This is where the <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> class comes in. A <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> is a workspace for adding and routing DspComponents. In this section we will have a look at how to create a simple DSPatch application using <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a>.</p>
<p>First we must include the DSPatch header and any other headers that contain DspComponents we wish to use in our application:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;DSPatch.h&quot;</span>
<span class="preprocessor">#include &quot;components.h&quot;</span>
</pre></div><p>Next, we must instantiate our <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> object and all <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> objects needed for our circuit. Lets say we had 2 other components included with "DspAnd" (from the first tutorial): "DspRandBool" (generates a random boolean value then outputs the result) and "DspPrintBool" (receives a boolean value and outputs it to the console):</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> main()
{
        <span class="comment">// 1. Create a DspCircuit where we can route our components</span>
        <span class="comment">// ========================================================</span>
        <a class="code" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> circuit;

        <span class="comment">// 2. Create instances of the components needed for our circuit</span>
        <span class="comment">// ============================================================</span>
        DspRandBool* randBoolGen1 = <span class="keyword">new</span> DspRandBool();
        DspRandBool* randBoolGen2 = <span class="keyword">new</span> DspRandBool();
        DspAnd* logicAnd = <span class="keyword">new</span> DspAnd();
        DspPrintBool* boolPrinter = <span class="keyword">new</span> DspPrintBool();
</pre></div><p>Now that we have a circuit and some components, lets add all of our components to the circuit:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// 3. Add component instances to circuit</span>
        <span class="comment">// =====================================</span>

        circuit.AddComponent( randBoolGen1, <span class="stringliteral">&quot;Bool Generator 1&quot;</span> );
        circuit.AddComponent( randBoolGen2, <span class="stringliteral">&quot;Bool Generator 2&quot;</span> );
        circuit.AddComponent( logicAnd, <span class="stringliteral">&quot;Logic AND&quot;</span> );
        circuit.AddComponent( boolPrinter, <span class="stringliteral">&quot;Bool Printer&quot;</span> );
</pre></div><p>The string values passed into the AddComponent() method calls are component names / IDs. Unlike signal names, component names are compulsory when added to a circuit. Although we still have the option of referencing a component via it's pointer in a circuit, forcing component string IDs causes circuit objects to be entirely self-contained. This gives us the ability to pass circuits around by reference, allowing the receiver access to all circuit components via their string ID references.</p>
<p>We are now ready to begin wiring the circuit:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// 4. Wire up the components inside the circuit</span>
        <span class="comment">// ============================================</span>

        circuit.ConnectOutToIn( randBoolGen1, 0, logicAnd, 0 );
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 1&quot;, 0, &quot;Logic AND&quot;, 0 );</span>
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 1&quot;, 0, &quot;Logic AND&quot;, &quot;input1&quot; );</span>

        circuit.ConnectOutToIn( randBoolGen2, 0, logicAnd, 1 );
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 2&quot;, 0, &quot;Logic AND&quot;, 1 );</span>
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 2&quot;, 0, &quot;Logic AND&quot;, &quot;input2&quot; );</span>

        circuit.ConnectOutToIn( logicAnd, 0, boolPrinter, 0 );
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Logic AND&quot;, 0, &quot;Bool Printer&quot;, 0 );</span>
        <span class="comment">//OR circuit.ConnectOutToIn( &quot;Logic AND&quot;, &quot;output&quot;, &quot;Bool Printer&quot;, 0 );</span>
</pre></div><p>The code above results in the following wiring configuration: </p>
<div class="fragment"><pre class="fragment">                                       ___________
        [<span class="stringliteral">&quot;Bool Generator 1&quot;</span>] 0 ---&gt; 0 |           |
                                      |<span class="stringliteral">&quot;Logic AND&quot;</span>| 0 ---&gt; 0 [<span class="stringliteral">&quot;Bool Printer&quot;</span>]
        [<span class="stringliteral">&quot;Bool Generator 2&quot;</span>] 0 ---&gt; 1 |___________|
</pre></div><p>Lastly, in order for our circuit to do any work it must be ticked over. This is performed by repeatedly calling the circuit's Tick() and Reset() methods. These methods can be called manually in a loop from the main application thread, or alternatively, by calling StartAutoTick(), a seperate thread will spawn, automatically calling Tick() and Reset() continuously. A circuit's thread count can be adjusted at runtime, allowing us to increase / decrease the number of threads use by the circuit as required during execution:</p>
<div class="fragment"><pre class="fragment">        <span class="comment">// 5. Tick the circuit</span>
        <span class="comment">// ===================</span>

        <span class="comment">// Circuit tick method 1: Manual</span>
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 10; i++ )
        {
                circuit.Tick();
                circuit.Reset();
        }

        <span class="comment">// Circuit tick method 2: Automatic</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Press any key to begin circuit auto-tick.&quot;</span>;
        getchar();
        circuit.StartAutoTick();

        <span class="comment">// Increase circuit thread count for higher performance</span>
        getchar();
        circuit.SetThreadCount( 4 );

        <span class="comment">// Press any key to quit</span>
        getchar();

        <span class="comment">// DspCircuit&#39;s destructor takes care of component garbage collection</span>
}
</pre></div><p>(All the source code from these tutorials can be found under the "tutorial" folder in the DSPatch root directory).</p>
<p><br/>
</p>
<h2><a class="anchor" id="release_notes"></a>
Release Notes</h2>
<h3><a class="anchor" id="v22"></a>
v.2.2 (08 December 2012)</h3>
<ul>
<li>Added coding tutorials</li>
<li>Cleaned up project directory structure.</li>
<li>Comments and documentation updates.</li>
<li>Components can no longer exist in multiple circuits.</li>
<li>Resolved component / circuit thread count clash.</li>
</ul>
<h3><a class="anchor" id="v21"></a>
v.2.1 (06 November 2012)</h3>
<ul>
<li>Removed DspSafePointer class.</li>
<li>Greatly improved overall performance.</li>
<li>Added commenting for doxygen.</li>
</ul>
<h3><a class="anchor" id="v20"></a>
v.2.0 (02 November 2012)</h3>
<ul>
<li>Re-licensed DSPatch to LGPL.</li>
<li>Added support for non-threaded platforms.</li>
<li>Circuit routing upgraded to more flexible template methods.</li>
</ul>
<h3><a class="anchor" id="v12"></a>
v.1.2 (20 October 2012)</h3>
<ul>
<li>Ported to Unix-based OS's.</li>
<li>Completed circuit-in-circuit logic.</li>
</ul>
<h3><a class="anchor" id="v11"></a>
v.1.1 (17 October 2012)</h3>
<ul>
<li>Varies bug fixes.</li>
<li>Added 2 more components to the DspDemo project.</li>
<li>Optimized threaded circuit processing.</li>
<li>AddComponent() updated to accept pre-constructed DspComponents. </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 9 2012 00:39:01 for DSPatch by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
