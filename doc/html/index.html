<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Flow-Based Programming</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="heartbeat.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">DSPatch
   &#160;<span id="projectnumber">v.2.42</span>
   </div>
   <div id="projectbrief">C++ Cross-Platform, Object-Oriented, Flow-Based Programming Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Welcome! </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p><a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a>, pronounced "dispatch", is a powerful C++ flow-based programming library that allows you to create and route (or "patch") high performance data processing circuits. <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> is not limited to any particular type of circuit or signal, its generic object-oriented API allows you to create almost any process chain imaginable, from simple logic circuits to full-blown electronics simulation. <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a>'s simple framework makes development quick and easy, allowing you to hit the ground running on every project.</p>
<p><a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> is designed around the concept of a "circuit" containing "components", interconnected via "wires" that transfer "signals" to and from input and output "buses". For more detail on how <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> works, check out the <a href="spec_page.html"><b>DSPatch Design Specification</b></a>.</p>
<p>The two most important classes to consider are <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> and <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a>. In order to route data to and from DspComponents they can either be added to an <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a>, where they can be wired together (recommended), or they can be wired directly via public <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> methods. The <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> engine takes care of data transfer between interconnected components, when data is ready for a component to process, a callback: "Process_()" is executed in that component. For a component to form part of the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> framework, designers simply have to derive their component from the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> base class, configure the component's IO buses, and implement the virtual Process_() callback method.</p>
<p><br/>
</p>
<h1><a class="anchor" id="features_sec"></a>
Features</h1>
<ul>
<li><b>Automatic branch synchronization</b> - The result of data diverging across parallel branches is guaranteed to arrive synchronized at a converging point.</li>
<li><b>Dynamic thread count adjustment</b> - Specify at run-time, the number of threads in which you require a circuit to process.</li>
<li><b>Easy-to-use object-oriented API</b> - <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> is modeled around real-world circuit entities and concepts, making code more readable and easy to understand.</li>
<li><b>Feedback loops</b> - Create true closed-circuit systems by feeding resultant signals back into previous component inputs.</li>
<li><b>High performance parallel processing</b> - Circuits use advanced multi-threaded scheduling to maximize data flow efficiency.</li>
<li><b>Integrated circuits</b> - Build circuits within circuits to encapsulate complex component networks into single circuit components.</li>
<li><b>Non-threaded platform support</b> - Develop for (or port to) platforms without multi-threading support and process complex circuit systems in a single thread.</li>
<li><b>Run-time circuit wiring</b> - Connect and disconnect wires on the fly whilst maintaining steady data flow through the system.</li>
<li><b>Run-time adaptive signal types</b> - Component inputs can accept values of run-time varying types allowing you to create more flexible, multi-purpose component processes.</li>
</ul>
<p><br/>
</p>
<h1><a class="anchor" id="install_sec"></a>
Getting Started</h1>
<h2><a class="anchor" id="step1"></a>
Step 1: Download DSPatch</h2>
<p>The <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> library can be downloaded from the <a href="https://sourceforge.net/projects/dspatch/"><b>SourceForge project page</b></a>. Download the project archive and extract the contents anywhere you like.</p>
<h2><a class="anchor" id="step2"></a>
Step 2: Read the Tutorials</h2>
<p>The "Tutorials" section below covers 2 vital aspects to developing with <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a>:</p>
<ol type="1">
<li>Creating a <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> - This tutorial is a start to finish demonstration of how to create a <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> component.</li>
<li>Building a <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> - In this tutorial you will learn how to use the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> framework to interconnect and process <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> networks using the <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> interface.</li>
</ol>
<h2><a class="anchor" id="step3"></a>
Step 3: Check out the DspDemo project</h2>
<p>In the "example" folder (in the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> root directory) you will find a simple <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> example project: "DspDemo". This project has been written to assist developers in understanding the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> API as well as to demonstrate how it could be used to build a real-time audio process chain. The quickest way to get this project compiled and running is to simply open the "dspdemo.sln" (Windows) or "dspdemo.xcodeproj" (Mac OS X) file (found in the "/example/windows", and "/example/mac_os_x" directories respectively) depending on the platform used -This solution contains both the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> library and DspDemo project side-by-side as would be typical in developing a <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> application.</p>
<h2><a class="anchor" id="step4"></a>
Step 4: Make your own DspComponents</h2>
<p>A fast way to create your own <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> could be to copy an existing component to another destination, rename it, and edit the contents to satisfy your component's required behavior. In the "example" folder (from Step 3) you will find 2 source files: "DspAdder.h" and "DspAdder.cpp". These files make up a very simple <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> that receives 2 floating-point buffers into it's 2 inputs, adds each buffer element of the 1st buffer to the corresponding element of the 2nd buffer, then passes the resultant buffer to the output. Alternatively, you could just copy / reference the source code from the "Creating a DspComponent" tutorial (found under the "tutorial" folder in the root directory).</p>
<h2><a class="anchor" id="step5"></a>
Step 5: Roll your own DSPatch projects</h2>
<p>As <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> is not reliant on any non-standard 3rd party sources, getting a <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> project to compile and run is relatively painless. All you need to do from your project is #include "DSPatch.h" from the "include" folder (in the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> root directory), and link to the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> library (either by including all <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> source or by linking to a compiled library file). To speed things up you may want to copy, rename, and edit the DspDemo project from step 3 to get up and running faster.</p>
<h2><a class="anchor" id="step6"></a>
Step 6: Refer to the documentation</h2>
<p>Between the DspDemo project, the DspAdder component template, and the documentation found here, you should have enough resources to get started with <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> straight away. If you have any questions or wish to report a bug, feel free to email me at <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'cu'+'s@a'+'da'+'pta'+'ud'+'io.'+'co'+'m'; return false;">marcu<span style="display: none;">.nosp@m.</span>s@ad<span style="display: none;">.nosp@m.</span>aptau<span style="display: none;">.nosp@m.</span>dio.<span style="display: none;">.nosp@m.</span>com</a>.</p>
<p><br/>
</p>
<h1><a class="anchor" id="tutorial_sec"></a>
Tutorials</h1>
<h2><a class="anchor" id="create_component"></a>
1. Creating a DspComponent</h2>
<p>In order to create a new <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a>, we must derive our component class from the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> base class, configure component IO, and implement the inherited virtual "Process_()" method.</p>
<p>Lets take a look at how we would go about creating a boolean logic "AND" component. This component will accept 2 boolean input values and output the result of: input 1 &amp;&amp; input 2.</p>
<p>We begin by deriving our new "DspAnd" component from <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Derive component class from DspComponent</span></div>
<div class="line"><span class="comment">// ===========================================</span></div>
<div class="line"><span class="keyword">class </span>DspAnd : <span class="keyword">public</span> <a class="code" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a></div>
<div class="line">{</div>
</div><!-- fragment --><p>The next step is to configure our component's input and output buses. This is achieved by calling the base protected methods AddInput_() and AddOutput_() respectively from our component's constructor. Each method must be called once per input / output required. In our component's case, we require 2 inputs and 1 output, therefore our constructor code will look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// 2. Configure component IO buses</span></div>
<div class="line">  <span class="comment">// ===============================</span></div>
<div class="line">  DspAnd()</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// add 2 inputs</span></div>
<div class="line">    AddInput_( <span class="stringliteral">&quot;input1&quot;</span> );</div>
<div class="line">    AddInput_( <span class="stringliteral">&quot;input2&quot;</span> );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add 1 output</span></div>
<div class="line">    AddOutput_( <span class="stringliteral">&quot;output&quot;</span> );</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The string values passed into the AddInput_() and AddOutput_() method calls are signal names / IDs. As component IO can be referenced by either string ID or index, IO signal names are optional. If we do not require a signal to have a string ID associated with it, we can simply leave the parenthesis empty.</p>
<p>Lastly, our component must implement the <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> virtual Process_() method. This is where our component does it's work. The Process_() method provides us with 2 parameters: the input bus and the output bus. It is our duty as the component designer to pull the inputs we require out of the input bus, process them accordingly, and populate the output bus with the results. Our component's process method will look something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="comment">// 3. Implement virtual Process_() method</span></div>
<div class="line">  <span class="comment">// ======================================</span></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Process_( <a class="code" href="class_dsp_signal_bus.html" title="DspSignal container.">DspSignalBus</a>&amp; inputs, <a class="code" href="class_dsp_signal_bus.html" title="DspSignal container.">DspSignalBus</a>&amp; outputs )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// create local stack variables to hold input values</span></div>
<div class="line">    <span class="keywordtype">bool</span> bool1 = <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> bool2 = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get values from inputs bus ( GetValue() returns true if successful )</span></div>
<div class="line">    <span class="keywordflow">if</span>( inputs.GetValue( 0, bool1 ) &amp;&amp; <span class="comment">//OR inputs.GetValue( &quot;input1&quot;, bool1 );</span></div>
<div class="line">        inputs.GetValue( 1, bool2 ) )  <span class="comment">//OR inputs.GetValue( &quot;input2&quot;, bool2 );</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// set output as the result of bool1 AND bool2</span></div>
<div class="line">      outputs.SetValue( 0, bool1 &amp;&amp; bool2 ); <span class="comment">//OR outputs.SetValue( &quot;output&quot;, bool1 &amp;&amp; bool2 );</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>And that's it! Our component is now ready to form part of the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> framework. Next we'll look at how we can add our component to a <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> and route it to and from other DspComponents.</p>
<p><br/>
</p>
<h2><a class="anchor" id="use_component"></a>
2. Building a DspCircuit</h2>
<p>In order for us to get any real use out of our DspComponents, we need them to interact with each other. This is where the <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> class comes in. A <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> is a workspace for adding and routing DspComponents. In this section we will have a look at how to create a simple <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> application that generates random boolean pairs, performs a logic AND on each pair, then prints the result to screen.</p>
<p>First we must include the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> header and any other headers that contain DspComponents we wish to use in our application:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DSPatch.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;components.h&quot;</span></div>
</div><!-- fragment --><p>Next, we must instantiate our <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> object and all <a class="el" href="class_dsp_component.html" title="Abstract base class for all DSPatch components.">DspComponent</a> objects needed for our circuit. Lets say we had 2 other components included with "DspAnd" (from the first tutorial): "DspRandBool" (generates a random boolean value then outputs the result) and "DspPrintBool" (receives a boolean value and outputs it to the console):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// 1. Create a DspCircuit where we can route our components</span></div>
<div class="line">  <span class="comment">// ========================================================</span></div>
<div class="line">  <a class="code" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> circuit;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// 2. Create instances of the components needed for our circuit</span></div>
<div class="line">  <span class="comment">// ============================================================</span></div>
<div class="line">  DspRandBool randBoolGen1;</div>
<div class="line">  DspRandBool randBoolGen2;</div>
<div class="line">  DspAnd logicAnd;</div>
<div class="line">  DspPrintBool boolPrinter;</div>
</div><!-- fragment --><p>Now that we have a circuit and some components, lets add all of our components to the circuit:</p>
<div class="fragment"><div class="line">  <span class="comment">// 3. Add component instances to circuit</span></div>
<div class="line">  <span class="comment">// =====================================</span></div>
<div class="line">  circuit.AddComponent( randBoolGen1, <span class="stringliteral">&quot;Bool Generator 1&quot;</span> );</div>
<div class="line">  circuit.AddComponent( randBoolGen2, <span class="stringliteral">&quot;Bool Generator 2&quot;</span> );</div>
<div class="line">  circuit.AddComponent( logicAnd, <span class="stringliteral">&quot;Logic AND&quot;</span> );</div>
<div class="line">  circuit.AddComponent( boolPrinter, <span class="stringliteral">&quot;Bool Printer&quot;</span> );</div>
</div><!-- fragment --><p>The string values passed into the AddComponent() method calls are component names / IDs. Although we still have the option of referencing a component via it's pointer in a circuit, component string IDs can allow circuit objects to be entirely self-contained. This could give us the ability to pass circuits around by reference, allowing the receiver access to all circuit components via their string IDs, without having to manage both component and circuit references everywhere.</p>
<p>We are now ready to begin wiring the circuit:</p>
<div class="fragment"><div class="line">  <span class="comment">// 4. Wire up the components inside the circuit</span></div>
<div class="line">  <span class="comment">// ============================================</span></div>
<div class="line"></div>
<div class="line">  circuit.ConnectOutToIn( randBoolGen1, 0, logicAnd, 0 );</div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 1&quot;, 0, &quot;Logic AND&quot;, 0 );</span></div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 1&quot;, 0, &quot;Logic AND&quot;, &quot;input1&quot; );</span></div>
<div class="line"></div>
<div class="line">  circuit.ConnectOutToIn( randBoolGen2, 0, logicAnd, 1 );</div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 2&quot;, 0, &quot;Logic AND&quot;, 1 );</span></div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Bool Generator 2&quot;, 0, &quot;Logic AND&quot;, &quot;input2&quot; );</span></div>
<div class="line"></div>
<div class="line">  circuit.ConnectOutToIn( logicAnd, 0, boolPrinter, 0 );</div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Logic AND&quot;, 0, &quot;Bool Printer&quot;, 0 );</span></div>
<div class="line">  <span class="comment">//OR circuit.ConnectOutToIn( &quot;Logic AND&quot;, &quot;output&quot;, &quot;Bool Printer&quot;, 0 );</span></div>
</div><!-- fragment --><p>The code above results in the following wiring configuration: </p>
<div class="fragment"><div class="line">                                 ___________</div>
<div class="line">  [<span class="stringliteral">&quot;Bool Generator 1&quot;</span>] 0 ---&gt; 0 |           |</div>
<div class="line">                                |<span class="stringliteral">&quot;Logic AND&quot;</span>| 0 ---&gt; 0 [<span class="stringliteral">&quot;Bool Printer&quot;</span>]</div>
<div class="line">  [<span class="stringliteral">&quot;Bool Generator 2&quot;</span>] 0 ---&gt; 1 |___________|</div>
</div><!-- fragment --><p>*N.B. Each component input can only accept one wire at a time. When another wire is connected to an input that already has a connected wire, that wire is replaced with the new one. One output, on the other hand, can be distributed to multiple inputs.</p>
<p>Lastly, in order for our circuit to do any work it must be ticked over. This is performed by repeatedly calling the circuit's Tick() and Reset() methods. These methods can be called manually in a loop from the main application thread, or alternatively, by calling StartAutoTick(), a seperate thread will spawn, automatically calling Tick() and Reset() continuously. A circuit's thread count can be adjusted at runtime, allowing us to increase / decrease the number of threads use by the circuit as required during execution:</p>
<div class="fragment"><div class="line">  <span class="comment">// 5. Tick the circuit</span></div>
<div class="line">  <span class="comment">// ===================</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Circuit tick method 1: Manual</span></div>
<div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i = 0; i &lt; 10; i++ )</div>
<div class="line">  {</div>
<div class="line">    circuit.Tick();</div>
<div class="line">    circuit.Reset();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Circuit tick method 2: Automatic</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Press any key to begin circuit auto-tick.&quot;</span>;</div>
<div class="line">  getchar();</div>
<div class="line">  circuit.StartAutoTick();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Increase circuit thread count for higher performance</span></div>
<div class="line">  getchar();</div>
<div class="line">  circuit.SetThreadCount( 4 );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Press any key to quit</span></div>
<div class="line">  getchar();</div>
</div><!-- fragment --><p>Lastly, the DSPatch::Finalize() method must be called on application exit in order for <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> to perform its own internal memory cleanup.</p>
<div class="fragment"><div class="line">  <span class="comment">// 6. Clean up</span></div>
<div class="line">  <span class="comment">// ===========</span></div>
<div class="line">  DSPatch::Finalize();</div>
<div class="line">}</div>
</div><!-- fragment --><p>(All the source code from these tutorials can be found under the "tutorial" folder in the <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> root directory).</p>
<p><br/>
</p>
<h1><a class="anchor" id="release_notes"></a>
Release Notes</h1>
<h2><a class="anchor" id="v242"></a>
v.2.42 (24 June 2013)</h2>
<ul>
<li>Added vs2008 and vs2010 versions of dspdemo.</li>
<li>Code style and performance improvements.</li>
</ul>
<h2><a class="anchor" id="v241"></a>
v.2.41 (07 February 2013)</h2>
<ul>
<li>Fixed VS2010 DspDemo linker errors.</li>
</ul>
<h2><a class="anchor" id="v240"></a>
v.2.40 (04 February 2013)</h2>
<ul>
<li>Optimized <a class="el" href="class_dsp_run_type.html" title="Dynamically typed variable.">DspRunType</a>.</li>
<li>Added Stop() method to <a class="el" href="class_dsp_thread.html" title="Cross-platform, object-oriented thread.">DspThread</a>.</li>
<li>Reduced pointer dereferencing and temporaries.</li>
</ul>
<h2><a class="anchor" id="v233"></a>
v.2.33 (01 February 2013)</h2>
<ul>
<li>Signal reading / writing optimized.</li>
<li>Code cleaned up and re-formatted.</li>
</ul>
<h2><a class="anchor" id="v232"></a>
v.2.32 (24 January 2013)</h2>
<ul>
<li>Reduced component thread mutex locking.</li>
<li>Fixed <a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> AddInput() run-time error.</li>
<li>Documentation updates.</li>
</ul>
<h2><a class="anchor" id="v231"></a>
v.2.31 (19 December 2012)</h2>
<ul>
<li>Improved synchronization in AddComponent().</li>
<li>Component routing upgraded to template methods.</li>
</ul>
<h2><a class="anchor" id="v230"></a>
v.2.30 (15 December 2012)</h2>
<ul>
<li>Circuit routing simplified.</li>
<li>Completed "circuit-less" component processing.</li>
<li>Component names now optional.</li>
<li><a class="el" href="class_dsp_circuit.html" title="Workspace for adding and routing components.">DspCircuit</a> no longer deletes external memory.</li>
<li>Optimized circuit-in-circuit processing.</li>
</ul>
<h2><a class="anchor" id="v22"></a>
v.2.2 (08 December 2012)</h2>
<ul>
<li>A component can no longer exist in multiple circuits.</li>
<li>Added coding tutorials</li>
<li>Cleaned up project directory structure.</li>
<li>Comments and documentation updates.</li>
<li>Resolved component / circuit thread count clash.</li>
</ul>
<h2><a class="anchor" id="v21"></a>
v.2.1 (06 November 2012)</h2>
<ul>
<li>Removed DspSafePointer class.</li>
<li>Greatly improved overall performance.</li>
<li>Added commenting for doxygen.</li>
</ul>
<h2><a class="anchor" id="v20"></a>
v.2.0 (02 November 2012)</h2>
<ul>
<li>Re-licensed <a class="el" href="class_d_s_patch.html" title="System-wide DSPatch functionality.">DSPatch</a> to LGPL.</li>
<li>Added support for non-threaded platforms.</li>
<li>Circuit routing upgraded to more flexible template methods.</li>
</ul>
<h2><a class="anchor" id="v12"></a>
v.1.2 (20 October 2012)</h2>
<ul>
<li>Ported to Unix-based OS's.</li>
<li>Completed circuit-in-circuit logic.</li>
</ul>
<h2><a class="anchor" id="v11"></a>
v.1.1 (17 October 2012)</h2>
<ul>
<li>Various bug fixes.</li>
<li>Added 2 more components to the DspDemo project.</li>
<li>Optimized threaded circuit processing.</li>
<li>AddComponent() updated to accept pre-constructed DspComponents.</li>
</ul>
<h2><a class="anchor" id="v10"></a>
v.1.0 (14 October 2012)</h2>
<ul>
<li>Extracted routing engine behind "Crosstalk" to form: "DSPatch". </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 24 2013 19:14:04 for DSPatch by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
